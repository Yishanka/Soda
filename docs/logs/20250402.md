# **SODA 速搭 数据库关系报告**  
📝 **版本：2025-04-02**  

## **📌 1. 需求分析**  
- **用户 (User)**
  - 可以**创建多个活动**，即一个用户可能是多个活动的创建者。
  - 可以**参与多个活动**，即用户既可以是自己活动的参与者，也可以加入别人创建的活动。  
  - **自己创建的活动，一定参与**。  

- **活动 (Activity)**
  - 可以有**多个用户**参与，且其中**至少一个是创建者**。  
  - **用户之间是搭子关系**，即用户和用户之间因共同参与活动而形成连接。

---

## **📌 2. 数据库设计**  
根据上述需求，用户和活动之间存在**多对多关系**，这需要一个**中间表**来存储用户与活动的对应关系。  

### **✅ 用户表 (User)**  
| 字段名        | 类型              | 说明 |
|--------------|-----------------|----|
| `id`        | `Integer (PK)`   | 用户 ID |
| `username`  | `String(50)`     | 用户名 |
| `email`     | `String(100)`    | 邮箱 |
| `password_hash` | `String(256)` | 哈希密码 |
| `created_at` | `DateTime`       | 注册时间 |
| **🔗 关系** | `activities (多对多)` | 该用户参与的所有活动 |

---

### **✅ 活动表 (Activity)**  
| 字段名        | 类型              | 说明 |
|--------------|-----------------|----|
| `id`        | `Integer (PK)`   | 活动 ID |
| `title`     | `String(255)`    | 活动标题 |
| `description` | `Text`         | 活动描述 |
| `created_at` | `DateTime`       | 创建时间 |
| **🔗 关系** | `participants (多对多)` | 参与此活动的所有用户 |

---

### **✅ 用户-活动关系表 (Participation)（中间表）**  
| 字段名         | 类型              | 说明 |
|---------------|-----------------|----|
| `user_id`     | `Integer (FK → users.id)` | 用户 ID |
| `activity_id` | `Integer (FK → activities.id)` | 活动 ID |
| `is_creator`  | `Boolean`        | 是否是创建者 (True/False) |

---

## **📌 3. Flask SQLAlchemy 代码实现**  
### **用户模型 (User)**
```python
from datetime import datetime
from app import db
from werkzeug.security import generate_password_hash, check_password_hash

class User(db.Model):
    __tablename__ = 'users'

    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(50), unique=True, nullable=False)
    email = db.Column(db.String(100), unique=True, nullable=False)
    password_hash = db.Column(db.String(256), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    # 通过中间表 participation 关联活动
    activities = db.relationship('Activity', secondary='participation', back_populates='participants')

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

    def __repr__(self):
        return f'<User {self.username}>'
```

---

### **活动模型 (Activity)**
```python
class Activity(db.Model):
    __tablename__ = 'activities'

    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(255), nullable=False)
    description = db.Column(db.Text, nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    # 通过中间表 participation 关联用户
    participants = db.relationship('User', secondary='participation', back_populates='activities')

    def __repr__(self):
        return f'<Activity {self.title}>'
```

---

### **用户-活动关系模型 (Participation)**
```python
class Participation(db.Model):
    __tablename__ = 'participation'

    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), primary_key=True)
    activity_id = db.Column(db.Integer, db.ForeignKey('activities.id'), primary_key=True)
    is_creator = db.Column(db.Boolean, default=False)  # 是否是创建者

    # 关系（不需要额外的 back_populates，因为已经在 User 和 Activity 里定义）
    user = db.relationship(User, backref=db.backref("participation", cascade="all, delete-orphan"))
    activity = db.relationship(Activity, backref=db.backref("participation", cascade="all, delete-orphan"))

    def __repr__(self):
        return f'<Participation user_id={self.user_id} activity_id={self.activity_id} creator={self.is_creator}>'
```

---

## **📌 4. 关系总结**
1. **用户与活动是多对多关系**，通过 `Participation` 表管理。
2. **`is_creator=True` 表示用户是创建者**，否则只是参与者。
3. **每个活动至少有一个创建者**，且创建者也会自动成为参与者。

---

## **📌 5. 数据操作示例**
### **创建活动**
```python
def create_activity(user_id, title, description):
    new_activity = Activity(title=title, description=description)
    db.session.add(new_activity)
    db.session.commit()

    # 添加创建者到 participation
    participation = Participation(user_id=user_id, activity_id=new_activity.id, is_creator=True)
    db.session.add(participation)
    db.session.commit()
```

### **添加参与者**
```python
def add_participant(user_id, activity_id):
    participation = Participation(user_id=user_id, activity_id=activity_id, is_creator=False)
    db.session.add(participation)
    db.session.commit()
```

### **获取某活动的所有参与者**
```python
def get_activity_participants(activity_id):
    activity = Activity.query.get(activity_id)
    return [p.username for p in activity.participants]
```

### **获取某用户的所有活动**
```python
def get_user_activities(user_id):
    user = User.query.get(user_id)
    return [(a.id, a.title) for a in user.activities]
```

---

## **📌 6. 未来开发方向**
✅ **基本功能**
- [x] 用户注册/登录  
- [x] 创建活动并自动成为创建者和参与者  
- [x] 参与活动  

🚀 **扩展功能**
- [ ] 退出活动（但创建者不能退出）  
- [ ] 生成“搭子”推荐，基于用户共同参与的活动  
- [ ] 活动状态管理（如活动满员、活动结束）  

---

## **📌 7. 结论**
你现在的数据库设计已经清晰：
1. **用户-活动是多对多**，通过 `Participation` 表管理。
2. **创建者也是活动参与者**。
3. **关系设计合理，查询高效**。

还要搞tags的显示


# Flask 初始化数据表并生成 Migration 文件夹

## 3. 初始化 Migration 文件夹

在项目根目录下运行以下命令：

```bash
flask db init
```

这会创建一个 `migrations` 文件夹，结构如下：

```
migrations/
    versions/  # 存放具体的迁移脚本
    env.py    # 迁移环境配置
    script.py.mako  # 迁移脚本模板
    README
```

## 4. 创建第一个迁移

运行以下命令创建初始迁移：

```bash
flask db migrate -m "initial migration"
```

这会扫描你的模型与当前数据库状态（此时应该是空数据库）的差异，并在 `migrations/versions` 中生成一个迁移脚本。

## 5. 应用迁移到数据库

运行以下命令将迁移应用到数据库：

```bash
flask db upgrade
```

这会创建所有定义的表。

## 6. 后续开发中的使用

当你修改模型后，重复以下步骤：

```bash
flask db migrate -m "your migration message"
flask db upgrade
```

## 注意事项

1. **数据库连接**：确保 `SQLALCHEMY_DATABASE_URI` 配置正确
2. **模型导入**：确保所有模型在运行迁移命令前已被导入
3. **Flask 应用工厂模式**：如果使用应用工厂模式，需要调整初始化方式：

```python
# 在工厂函数中
def create_app():
    app = Flask(__name__)
    # ...其他配置...
    db.init_app(app)
    migrate.init_app(app, db)
    return app
```

4. **多数据库支持**：如果需要支持多个数据库，需要更复杂的配置

通过以上步骤，你就可以在 Flask 项目中初始化数据库表并管理数据库迁移了。
